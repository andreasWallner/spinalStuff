package andreasWallner.xilinx

import andreasWallner.zynq.Dma
import spinal.core._
import spinal.lib._
import spinal.lib.bus.amba4.axilite.{
  AxiLite4,
  AxiLite4Ax,
  AxiLite4B,
  AxiLite4Config,
  AxiLite4R,
  AxiLite4W
}
import spinal.lib.bus.amba4.axi.{Axi4, Axi4Ax, Axi4B, Axi4Config, Axi4R, Axi4W}
import spinal.lib.IMasterSlave
import spinal.lib.bus.amba3.apb.Apb3

object XilinxSupportFactory {
  def makeSupport(bundle: IMasterSlave): Option[BusSupport] =
    bundle match {
      case axilite: AxiLite4 => Some(AxiLite4Support(axilite))
      case axi: Axi4         => Some(Axi4Support(axi))
      case apb: Apb3         => Some(Apb3Support(apb))
      case req: Dma.Request  => Some(DmaReqSupport(req))
      case ack: Dma.Ack      => Some(DmaAckSupport(ack))
      case _                 => None
    }
}

trait BusSupport {
  def name(idx: Integer): String

  def rename(idx: Integer): Unit

  def addAttributes(idx: Integer): Unit

  def portMaps(): List[PortMap]

  def busType: SpiritBusType

  def abstractionType: SpiritAbstractionType

  def clockInterfaceNames(idx: Integer): Option[String]
}

// see Vivado 2022.1 install directory, data/ip/xilinx/processing_system7_v5_5/component.xml
// search for DMA0_REQ
case class DmaReqSupport(req: Dma.Request) extends BusSupport {
  override def name(idx: Integer) = f"DMA${idx}_REQ"

  override def rename(idx: Integer): Unit = {
    val prefix = f"DMA${idx}_"
    req.drready.setName(prefix + "DRREADY")
    req.drlast.setName(prefix + "DRLAST")
    req.drvalid.setName(prefix + "DRVALID")
    req.drtype.setName(prefix + "DRTYPE")
  }

  override def addAttributes(idx: Integer): Unit = {
    def attr = "X_INTERFACE_INFO"
    def info = f"xilinx.com:interface:axis_rtl:1.0 ${name(idx)} "
    for (mapping <- portMaps())
      mapping.physicalPort.addAttribute(attr, info + mapping.logicalPort)
    req.drready.addAttribute(
      "X_INTERFACE_PARAMETER",
      f"""XIL_INTERFACENAME ${name(idx)}, HAS_TLAST TRUE, HAS_TKEEP FALSE, HAS_TSTRB FALSE, HAS_TREADY TRUE, TUSER_WIDTH 2, TID_WIDTH 0, TDEST_WIDTH 0, TDATA_NUM_BYTES 0"""
    )
  }

  override def portMaps() = {
    List(
      PortMap("TREADY", req.drready),
      PortMap("TLAST", req.drlast),
      PortMap("TVALID", req.drvalid),
      PortMap("TUSER", req.drtype)
    )
  }

  override def busType =
    SpiritBusType("xilinx.com", "interface", "axis_rtl", "1.0")

  override def abstractionType =
    SpiritAbstractionType("xilinx.com", "interface", "axis", "1.0")

  override def clockInterfaceNames(idx: Integer) =
    Some(f"${name(idx)}:${req.drready.getName()}")
}
case class DmaAckSupport(ack: Dma.Ack) extends BusSupport {
  override def name(idx: Integer) = f"DMA${idx}_ACK"

  override def rename(idx: Integer): Unit = {
    val prefix = f"DMA${idx}_"
    ack.daready.setName(prefix + "DAREADY")
    ack.davalid.setName(prefix + "DAVALID")
    ack.datype.setName(prefix + "DATYPE")
  }

  override def addAttributes(idx: Integer): Unit = {
    def attr = "X_INTERFACE_INFO"
    def info = f"xilinx.com:interface:axis_rtl:1.0 ${name(idx)} "
    for (mapping <- portMaps())
      mapping.physicalPort.addAttribute(attr, info + mapping.logicalPort)
    ack.daready.addAttribute(
      "X_INTERFACE_PARAMETER",
      f"""XIL_INTERFACENAME ${name(idx)}, HAS_TLAST FALSE, HAS_TKEEP FALSE, HAS_TSTRB FALSE, HAS_TREADY TRUE, TUSER_WIDTH 2, TID_WIDTH 0, TDEST_WIDTH 0, TDATA_NUM_BYTES 0"""
    )
  }

  override def portMaps() = {
    List(
      PortMap("TREADY", ack.daready),
      PortMap("TVALID", ack.davalid),
      PortMap("TUSER", ack.datype)
    )
  }

  override def busType =
    SpiritBusType("xilinx.com", "interface", "axis_rtl", "1.0")

  override def abstractionType =
    SpiritAbstractionType("xilinx.com", "interface", "axis", "1.0")

  override def clockInterfaceNames(idx: Integer) =
    Some(f"${name(idx)}:${ack.daready.getName()}")
}

/**
  * Rename Axi4-Lite bus as expected by Xilinx Vivado toolset
  *
  * Names are in accordance with what is autogenerated by Vivado.
  * See https://docs.xilinx.com/v/u/en-US/ug1037-vivado-axi-reference-guide
  */
case class AxiLite4Support(axilite: AxiLite4) extends BusSupport {
  def name(idx: Integer): String = {
    val dirPrefix = if (axilite.isMasterInterface) "M" else "S"
    val idxPrefix = f"$idx%02d"
    dirPrefix + idxPrefix + "_AXI"
  }

  def rename(idx: Integer): Unit = {
    val prefix = name(idx) + "_"

    renameAx(axilite.aw, prefix, "w")
    renameW(axilite.w, prefix)
    renameB(axilite.b, prefix)
    renameAx(axilite.ar, prefix, "r")
    renameR(axilite.r, prefix)
  }

  def renameAx(ax: Stream[AxiLite4Ax], prefix: String, rw: String): Unit = {
    ax.addr.setName(prefix + f"a${rw}addr")
    ax.prot.setName(prefix + f"a${rw}prot")
    ax.valid.setName(prefix + f"a${rw}valid")
    ax.ready.setName(prefix + f"a${rw}ready")
  }

  def renameW(w: Stream[AxiLite4W], prefix: String): Unit = {
    w.data.setName(prefix + f"wdata")
    w.strb.setName(prefix + f"wstrb")
    w.valid.setName(prefix + f"wvalid")
    w.ready.setName(prefix + f"wready")
  }

  def renameB(b: Stream[AxiLite4B], prefix: String): Unit = {
    b.resp.setName(prefix + f"bresp")
    b.valid.setName(prefix + f"bvalid")
    b.ready.setName(prefix + f"bready")
  }

  def renameR(r: Stream[AxiLite4R], prefix: String): Unit = {
    r.data.setName(prefix + f"rdata")
    r.resp.setName(prefix + f"rresp")
    r.valid.setName(prefix + f"rvalid")
    r.ready.setName(prefix + f"rready")
  }

  def portMaps(): List[PortMap] = {
    import axilite._
    List(
      PortMap("AWADDR", aw.addr),
      PortMap("AWPROT", aw.prot),
      PortMap("AWVALID", aw.valid),
      PortMap("AWREADY", aw.ready),
      PortMap("WDATA", w.data),
      PortMap("WSTRB", w.strb),
      PortMap("WVALID", w.valid),
      PortMap("WREADY", w.ready),
      PortMap("BRESP", b.resp),
      PortMap("BVALID", b.valid),
      PortMap("BREADY", b.ready),
      PortMap("ARADDR", ar.addr),
      PortMap("ARPROT", ar.prot),
      PortMap("ARVALID", ar.valid),
      PortMap("ARREADY", ar.ready),
      PortMap("RDATA", r.data),
      PortMap("RRESP", r.resp),
      PortMap("RVALID", r.valid),
      PortMap("RREADY", r.ready)
    )
  }

  def busType: SpiritBusType =
    SpiritBusType("xilinx.com", "interface", "aximm", "1.0")

  def abstractionType: SpiritAbstractionType =
    SpiritAbstractionType("xilinx.com", "interface", "aximm_rtl", "1.0")

  override def addAttributes(idx: Integer): Unit = {
    def attr = "X_INTERFACE_INFO"
    def info = "xilinx.com:interface:aximm:1.0 " + name(idx) + " "
    for (mapping <- portMaps())
      mapping.physicalPort.addAttribute(attr, info + mapping.logicalPort)
    axilite.r.ready.addAttribute(
      "X_INTERFACE_PARAMETER",
      f"XIL_INTERFACENAME ${name(idx)}, DATA_WIDTH ${axilite.config.dataWidth}, PROTOCOL AXI4LITE, ADDRESS_WIDTH ${axilite.config.addressWidth}"
    )
  }

  override def clockInterfaceNames(idx: Integer) =
    Some(f"${name(idx)}:${axilite.r.ready.getName()}")
}

// See Vivado 2022.1 install directory: data/ip/xilinx/axi_apb_bridge_v3_0/component.xml
// TODO finish
case class Apb3Support(apb3: Apb3) extends BusSupport {
  def dirPrefix = if (apb3.isMasterInterface) "M" else "S"

  def name(idx: Integer): String = {
    val idxPrefix = f"$idx%02d_APB"
    dirPrefix + idxPrefix + "_"
  }

  def rename(idx: Integer): Unit = {
    val prefix = name(idx)

    apb3.PADDR.setName(prefix + "PADDR")
    apb3.PENABLE.setName(prefix + "PENABLE")
    apb3.PRDATA.setName(prefix + "PRDATA")
    apb3.PREADY.setName(prefix + "PREADY")
    apb3.PSEL.setName(prefix + "PSEL")
    apb3.PSLVERROR.setName(prefix + "PSLVERR")
    apb3.PWDATA.setName(prefix + "PWDATA")
    apb3.PWRITE.setName(prefix + "PWRITE")
  }

  def addAttributes(idx: Integer): Unit = {
    def name = f"APB_${dirPrefix}${idx}"
    def attr = "X_INTERFACE_INFO"
    def info = "xilinx.com:interface:apb:1.0 " + name + " "
    for (mapping <- portMaps())
      mapping.physicalPort.addAttribute(attr, info + mapping.logicalPort)
    // TODO bus definition
  }

  override def portMaps() = List(
    PortMap("PADDR", apb3.PADDR),
    PortMap("PENABLE", apb3.PENABLE),
    PortMap("PRDATA", apb3.PRDATA),
    PortMap("PREADY", apb3.PREADY),
    PortMap("PSEL", apb3.PSEL),
    PortMap("PSLVERR", apb3.PSLVERROR),
    PortMap("PWDATA", apb3.PWDATA),
    PortMap("PWRITE", apb3.PWRITE)
  )

  override def busType = SpiritBusType("xilinx.com", "interface", "apb", "1.0")

  override def abstractionType =
    SpiritAbstractionType("xilinx.com", "interface", "apb_rtl", "1.0")

  override def clockInterfaceNames(idx: Integer) =
    Some(f"${name(idx)}:${apb3.PREADY.getName()}")
}

case class Axi4Support(axi4: Axi4) extends BusSupport {
  def name(idx: Integer): String = {
    val dirPrefix = if (axi4.isMasterInterface) "M" else "S"
    val idxPrefix = f"_AXI_$idx%02d"
    dirPrefix + idxPrefix + "_"
  }

  def rename(idx: Integer): Unit = {
    val prefix = name(idx)

    renameAx(axi4.aw, prefix, "W", axi4.config, axi4.config.awUserWidth)
    renameW(axi4.w, prefix, axi4.config)
    renameB(axi4.b, prefix, axi4.config)
    renameAx(axi4.ar, prefix, "R", axi4.config, axi4.config.arUserWidth)
    renameR(axi4.r, prefix, axi4.config)
  }

  def renameAx[T <: Axi4Ax](
      ax: Stream[T],
      prefix: String,
      rw: String,
      config: Axi4Config,
      userWidth: Int
  ): Unit = {
    import config._
    ax.addr.setName(prefix + f"A${rw}ADDR")
    if (useId) ax.id.setName(prefix + f"A${rw}ID")
    if (useRegion) ax.region.setName(prefix + f"A${rw}REGION")
    if (useLen) ax.len.setName(prefix + f"A${rw}LEN")
    if (useSize) ax.size.setName(prefix + f"A${rw}SIZE")
    if (useBurst) ax.burst.setName(prefix + f"A${rw}BURST")
    if (useLock) ax.lock.setName(prefix + f"A${rw}LOCK")
    if (useCache) ax.cache.setName(prefix + f"A${rw}CACHE")
    if (useQos) ax.qos.setName(prefix + f"A${rw}QOS")
    if (userWidth >= 0) ax.user.setName(prefix + f"A${rw}USER")
    if (useProt) ax.prot.setName(prefix + f"A${rw}PROT")
    ax.valid.setName(prefix + f"A${rw}VALID")
    ax.ready.setName(prefix + f"A${rw}READY")
  }

  def renameW(w: Stream[Axi4W], prefix: String, config: Axi4Config): Unit = {
    import config._
    w.data.setName(prefix + f"WDATA")
    if (useStrb) w.strb.setName(prefix + f"WSTRB")
    if (wUserWidth >= 0) w.user.setName(prefix + f"WUSER")
    if (useLast) w.last.setName(prefix + f"WLAST")
    w.valid.setName(prefix + f"WVALID")
    w.ready.setName(prefix + f"WREADY")
  }

  def renameB(b: Stream[Axi4B], prefix: String, config: Axi4Config): Unit = {
    import config._
    if (useId) b.id.setName(prefix + f"BID")
    if (useResp) b.resp.setName(prefix + f"BRESP")
    if (bUserWidth >= 0) b.user.setName(prefix + f"BUSER")
    b.valid.setName(prefix + f"BVALID")
    b.ready.setName(prefix + f"BREADY")
  }

  def renameR(r: Stream[Axi4R], prefix: String, config: Axi4Config): Unit = {
    import config._
    r.data.setName(prefix + f"RDATA")
    if (useId) r.id.setName(prefix + f"RID")
    if (useResp) r.resp.setName(prefix + f"RRESP")
    if (useLast) r.last.setName(prefix + f"RLAST")
    if (rUserWidth >= 0) r.user.setName(prefix + f"RUSER")
    r.valid.setName(prefix + f"RVALID")
    r.ready.setName(prefix + f"RREADY")
  }

  def portMaps(): List[PortMap] = {
    List(
      PortMap("AWID", axi4.aw.payload.id),
      PortMap("AWADDR", axi4.aw.payload.addr),
      PortMap("AWLEN", axi4.aw.payload.len),
      PortMap("AWSIZE", axi4.aw.payload.size),
      PortMap("AWBURST", axi4.aw.payload.burst),
      PortMap("AWLOCK", axi4.aw.payload.lock),
      PortMap("AWCACHE", axi4.aw.payload.cache),
      PortMap("AWPROT", axi4.aw.payload.prot),
      PortMap("AWREGION", axi4.aw.payload.region),
      PortMap("AWQOS", axi4.aw.payload.qos),
      PortMap("AWUSER", axi4.aw.payload.user),
      PortMap("AWVALID", axi4.aw.valid),
      PortMap("AWREADY", axi4.aw.ready),
      //PortMap("WID", axi4.w.payload.id),
      PortMap("WDATA", axi4.w.payload.data),
      PortMap("WSTRB", axi4.w.payload.strb),
      PortMap("WLAST", axi4.w.payload.last),
      PortMap("WUSER", axi4.w.payload.user),
      PortMap("WVALID", axi4.w.valid),
      PortMap("WREADY", axi4.w.ready),
      PortMap("BID", axi4.b.id),
      PortMap("BRESP", axi4.b.payload.resp),
      PortMap("BUSER", axi4.b.payload.user),
      PortMap("BVALID", axi4.b.valid),
      PortMap("BREADY", axi4.b.ready),
      PortMap("ARID", axi4.ar.payload.id),
      PortMap("ARADDR", axi4.ar.payload.addr),
      PortMap("ARLEN", axi4.ar.payload.len),
      PortMap("ARSIZE", axi4.ar.payload.size),
      PortMap("ARBURST", axi4.ar.payload.burst),
      PortMap("ARLOCK", axi4.ar.payload.lock),
      PortMap("ARCACHE", axi4.ar.payload.cache),
      PortMap("ARPROT", axi4.ar.payload.prot),
      PortMap("ARREGION", axi4.ar.payload.region),
      PortMap("ARQOS", axi4.ar.payload.qos),
      PortMap("ARUSER", axi4.ar.payload.user),
      PortMap("ARVALID", axi4.ar.valid),
      PortMap("ARREADY", axi4.ar.ready),
      PortMap("RID", axi4.r.id),
      PortMap("RDATA", axi4.r.data),
      PortMap("RRESP", axi4.r.resp),
      PortMap("RLAST", axi4.r.last),
      PortMap("RUSER", axi4.r.user),
      PortMap("RVALID", axi4.r.valid),
      PortMap("RREADY", axi4.r.ready)
    )
  }

  override def busType: SpiritBusType =
    SpiritBusType("xilinx.com", "interface", "aximm_rtl", "1.0")

  override def abstractionType: SpiritAbstractionType =
    SpiritAbstractionType("xilinx.com", "interface", "aximm_rtl", "1.0")

  override def addAttributes(idx: Integer): Unit = {
    def attr = "X_INTERFACE_INFO"
    def info = "xilinx.com:interface:aximm_rtl:1.0 " + name(idx) + " "
    for (mapping <- portMaps() if mapping.physicalPort != null)
      mapping.physicalPort.addAttribute(attr, info + mapping.logicalPort)
    axi4.r.ready.addAttribute(
      "X_INTERFACE_PARAMETER",
      f"XIL_INTERFACENAME ${name(idx)}, DATA_WIDTH ${axi4.config.dataWidth}, PROTOCOL AXI, ADDRESS_WIDTH ${axi4.config.addressWidth}"
    )
  }

  override def clockInterfaceNames(idx: Integer) =
    Some(f"${name(idx)}:${axi4.r.ready.getName()}")
}

object forMasterSlaveInterfaces {
  var slaveIdx = 0
  var masterIdx = 0

  def apply(that: Component)(f: (IMasterSlave, Int) => Boolean): Unit =
    traverse(that)(f)

  def traverse(that: Component)(f: (IMasterSlave, Int) => Boolean): Unit =
    that.getGroupedIO(true) foreach (process(_)(f))

  def traverse(b: Bundle)(f: (IMasterSlave, Int) => Boolean): Unit =
    b.elements foreach { case (_, d) => process(d)(f) }

  def process(d: Data)(f: (IMasterSlave, Int) => Boolean): Unit = {
    d match {
      case ms: IMasterSlave =>
        val idx = if (ms.isMasterInterface) masterIdx else slaveIdx
        val done = f(ms, idx)

        if (done) {
          if (ms.isMasterInterface) masterIdx else slaveIdx = idx + 1
          return
        }
      case _ =>
    }
    d match {
      case b: Bundle => traverse(b)(f)
      case _         =>
    }
  }
}

object XilinxNamer {
  def apply[T <: Component](comp: T): T = {
    def doIt: Unit = {
      val interfaceList = scala.collection.mutable.ArrayBuffer[String]()
      forMasterSlaveInterfaces(comp) { (intf: IMasterSlave, idx: Int) =>
        XilinxSupportFactory.makeSupport(intf) match {
          case Some(support) =>
            support.rename(idx)
            support.addAttributes(idx)
            support.clockInterfaceNames(idx).map(name => interfaceList += name)
            true
          case _ => false
        }
      }
      name_clockDomain(comp.clockDomain)
      // TODO deal with multiple clock domains...
      add_clockDomain_attributes(comp.clockDomain, interfaceList)
    }

    comp.rework {
      doIt
    }
    comp
  }

  def name_clockDomain(cd: ClockDomain): Unit = {
    cd.readClockWire.setName(
      "ACLK"
        + (cd.frequency match {
          case f: FixedFrequency =>
            Helper.engineeringNotation(f.getValue.toBigDecimal, "Hz")
          case _ => ""
        })
    )
    if (cd.hasResetSignal) {
      cd.readResetWire.setName(
        (if (cd.config.resetKind == ASYNC) "A" else "")
          + "RESET"
          + (if (cd.config.resetActiveLevel == HIGH) "" else "N")
      )
    }

    if (cd.hasClockEnableSignal) {
      cd.readClockEnableWire.setName(
        "CE" + (if (cd.config.resetActiveLevel == HIGH) "" else "N")
      )
    }
  }

  def add_clockDomain_attributes(
      cd: ClockDomain,
      interfaceList: Seq[String]
  ): Unit = {
    val clk = cd.readClockWire
    clk.addAttribute(
      "X_INTERFACE_INFO",
      s"xilinx.com:signal:clock:1.0 ${cd.clock.getName()} CLK"
    )

    val clk_params = scala.collection.mutable.ArrayBuffer[String]()
    if (cd.hasResetSignal)
      clk_params += "ASSOCIATED_RESET " + cd.reset.getName()
    cd.frequency match {
      case f: FixedFrequency => clk_params += "FREQ_HZ " + f.getValue.toBigDecimal.toString()
      case _ =>
    }
    if (interfaceList.nonEmpty) {
      // for format many thanks to pyzahl (see https://support.xilinx.com/s/question/0D52E00006hpKNdSAM/how-to-correctly-use-xinterfaceparameter-in-verilog-rtls-used-in-vivado?language=en_US)
      clk_params += "ASSOCIATED_BUSIF " + interfaceList.mkString(":")
    }
    clk.addAttribute("X_INTERFACE_PARAMETER", clk_params.mkString(", "))

    if (cd.hasResetSignal) {
      val rst = cd.readResetWire
      rst.addAttribute(
        "X_INTERFACE_INFO",
        s"xilinx.com:signal:reset:1.0 ${cd.reset.getName()} RST"
      )
      rst.addAttribute(
        "X_INTERFACE_PARAM",
        "POLARITY " + (if (cd.config.resetActiveLevel == HIGH) "ACTIVE_HIGH"
                       else "ACTIVE_LOW")
      )
    }
    if (cd.hasClockEnableSignal) {
      val ce = cd.readClockEnableWire
      ce.addAttribute(
        "X_INTERFACE_INFO",
        s"xilinx.com:signal:clockenable:1.0 ${cd.clockEnable.getName()} CE"
      )
      ce.addAttribute(
        "X_INTERFACE_PARAMETER",
        "POLARITY " + (if (cd.config.clockEnableActiveLevel == HIGH)
                         "ACTIVE_HIGH"
                       else "ACTIVE_LOW")
      )
    }
  }
}

object Helper {
  def engineeringNotation(
      d: BigDecimal,
      unit: String,
      decimalDigits: Int = 3
  ): String = {
    Seq(
      ("Y", BigDecimal("1000000000000000000000000")),
      ("Z", BigDecimal("1000000000000000000000")),
      ("E", BigDecimal("1000000000000000000")),
      ("P", BigDecimal("1000000000000000")),
      ("T", BigDecimal("1000000000000")),
      ("G", BigDecimal("1000000000")),
      ("M", BigDecimal("1000000")),
      ("k", BigDecimal("1000")),
      ("", BigDecimal("1")),
      ("m", BigDecimal("0.001")),
      ("u", BigDecimal("0.000001")),
      ("n", BigDecimal("0.000000001")),
      ("p", BigDecimal("0.000000000001")),
      ("f", BigDecimal("0.000000000000001")),
      ("a", BigDecimal("0.000000000000000001")),
      ("z", BigDecimal("0.000000000000000000001")),
      ("y", BigDecimal("0.000000000000000000000001"))
    ).collectFirst {
      case (prefix, multiplier: BigDecimal) if d >= multiplier =>
        (prefix, multiplier)
    } match {
      case Some((prefix: String, multiplier: BigDecimal)) =>
        (d / multiplier)
          .setScale(decimalDigits, BigDecimal.RoundingMode.HALF_UP) match {
          case v if v.isWhole() =>
            v.toInt.toString() + (if (prefix != "") prefix else unit)
          case v => // "thankfully" BigDecimal.toString is not locale aware...
            v.toString()
              .replace(".", if (prefix != "") prefix else unit)
              .replaceAll("0*$", "")
        }
      case _ =>
        throw new NumberFormatException(f"No valid SI-prefix available for $d")
    }
  }
}
