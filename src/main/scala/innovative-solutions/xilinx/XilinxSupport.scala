package innovative_solutions.xilinx

import spinal.core._
import spinal.lib._
import spinal.lib.bus.amba4.axilite.{
  AxiLite4,
  AxiLite4Ax,
  AxiLite4W,
  AxiLite4B,
  AxiLite4R,
  AxiLite4Config
}
import spinal.lib.bus.amba4.axi.{Axi4, Axi4Ax, Axi4W, Axi4B, Axi4R, Axi4Config}
import spinal.lib.IMasterSlave
import scala.collection.mutable.Map

trait BusSupport {
  def makeName(idx: Integer) : String
  def portMaps() : List[PortMap]
  def busType : SpiritBusType
  def abstractionType : SpiritAbstractionType
}

/**
  * Rename Axi4-Lite bus as expected by Xilinx Vivado toolset
  *
  * Names are in accordance with what is autogenerated by Vivado.
  */
case class AxiLite4Support(axilite: AxiLite4) extends BusSupport {
  def makeName(idx: Integer) = {
    val dirPrefix = if (axilite.isMasterInterface) "M" else "S"
    val idxPrefix = f"$idx%02d"
    dirPrefix + idxPrefix + "_AXI"
  }

  def apply(idx: Integer) = {
    val prefix = makeName(idx) + "_"

    renameAx(axilite.aw, prefix, "w")
    renameW(axilite.w, prefix)
    renameB(axilite.b, prefix)
    renameAx(axilite.ar, prefix, "r")
    renameR(axilite.r, prefix)
  }

  def renameAx(ax: Stream[AxiLite4Ax], prefix: String, rw: String) = {
    ax.addr.setName(prefix + f"a${rw}addr")
    ax.prot.setName(prefix + f"a${rw}prot")
    ax.valid.setName(prefix + f"a${rw}valid")
    ax.ready.setName(prefix + f"a${rw}ready")
  }

  def renameW(w: Stream[AxiLite4W], prefix: String) = {
    w.data.setName(prefix + f"wdata")
    w.strb.setName(prefix + f"wstrb")
    w.valid.setName(prefix + f"wvalid")
    w.ready.setName(prefix + f"wready")
  }

  def renameB(b: Stream[AxiLite4B], prefix: String) = {
    b.resp.setName(prefix + f"bresp")
    b.valid.setName(prefix + f"bvalid")
    b.ready.setName(prefix + f"bready")
  }

  def renameR(r: Stream[AxiLite4R], prefix: String) = {
    r.data.setName(prefix + f"rdata")
    r.resp.setName(prefix + f"rresp")
    r.valid.setName(prefix + f"rvalid")
    r.ready.setName(prefix + f"rready")
  }

  def portMaps(): List[PortMap] = {
    import axilite._
    List(
      PortMap("AWADDR", aw.addr),
      PortMap("AWPROT", aw.prot),
      PortMap("AWVALID", aw.valid),
      PortMap("AWREADY", aw.ready),
      PortMap("WDATA", w.data),
      PortMap("WSTRB", w.strb),
      PortMap("WVALID", w.valid),
      PortMap("WREADY", w.ready),
      PortMap("BRESP", b.resp),
      PortMap("BVALID", b.valid),
      PortMap("BREADY", b.ready),
      PortMap("ARADDR", ar.addr),
      PortMap("ARPROT", ar.prot),
      PortMap("ARVALID", ar.valid),
      PortMap("ARREADY", ar.ready),
      PortMap("RDATA", r.data),
      PortMap("RRESP", r.resp),
      PortMap("RVALID", r.valid),
      PortMap("RREADY", r.ready))
  }

  def busType = SpiritBusType("xilinx.com", "interface", "aximm", "1.0")
  def abstractionType = SpiritAbstractionType("xilinx.com", "interface", "aximm_rtl", "1.0")
}

object Axi4XilinxRenamer {
  def apply(axi: Axi4, idx: Integer) = {
    val dirPrefix = if (axi.isMasterInterface) "M" else "S"
    val idxPrefix = f"$idx%02d"
    val prefix = dirPrefix + idxPrefix + "_"

    renameAx(axi.aw, prefix, "W", axi.config, axi.config.awUserWidth)
    renameW(axi.w, prefix, axi.config)
    renameB(axi.b, prefix, axi.config)
    renameAx(axi.ar, prefix, "R", axi.config, axi.config.arUserWidth)
    renameR(axi.r, prefix, axi.config)
  }

  def renameAx[T <: Axi4Ax](
      ax: Stream[T],
      prefix: String,
      rw: String,
      config: Axi4Config,
      userWidth: Int
  ) = {
    import config._
    ax.addr.setName(prefix + f"A${rw}ADDR")
    if (useId) ax.id.setName(prefix + f"A${rw}ID")
    if (useRegion) ax.region.setName(prefix + f"A${rw}REGION")
    if (useLen) ax.len.setName(prefix + f"A${rw}LEN")
    if (useSize) ax.size.setName(prefix + f"A${rw}SIZE")
    if (useBurst) ax.burst.setName(prefix + f"A${rw}BURST")
    if (useLock) ax.lock.setName(prefix + f"A${rw}LOCK")
    if (useCache) ax.cache.setName(prefix + f"A${rw}CACHE")
    if (useQos) ax.qos.setName(prefix + f"A${rw}QOS")
    if (userWidth >= 0) ax.user.setName(prefix + f"A${rw}USER")
    if (useProt) ax.prot.setName(prefix + f"A${rw}PROT")
    ax.valid.setName(prefix + f"A${rw}VALID")
    ax.ready.setName(prefix + f"A${rw}READY")
  }

  def renameW(w: Stream[Axi4W], prefix: String, config: Axi4Config) = {
    import config._
    w.data.setName(prefix + f"WDATA")
    if (useStrb) w.strb.setName(prefix + f"WSTRB")
    if (wUserWidth >= 0) w.user.setName(prefix + f"WUSER")
    if (useLast) w.last.setName(prefix + f"WLAST")
    w.valid.setName(prefix + f"WVALID")
    w.ready.setName(prefix + f"WREADY")
  }

  def renameB(b: Stream[Axi4B], prefix: String, config: Axi4Config) = {
    import config._
    if (useId) b.id.setName(prefix + f"BID")
    if (useResp) b.resp.setName(prefix + f"BRESP")
    if (bUserWidth >= 0) b.user.setName(prefix + f"BUSER")
    b.valid.setName(prefix + f"BVALID")
    b.ready.setName(prefix + f"BREADY")
  }

  def renameR(r: Stream[Axi4R], prefix: String, config: Axi4Config) = {
    import config._
    r.data.setName(prefix + f"RDATA")
    if (useId) r.id.setName(prefix + f"RID")
    if (useResp) r.resp.setName(prefix + f"RRESP")
    if (useLast) r.last.setName(prefix + f"RLAST")
    if (rUserWidth >= 0) r.user.setName(prefix + f"RUSER")
    r.valid.setName(prefix + f"RVALID")
    r.ready.setName(prefix + f"RREADY")
  }
}

object ForMasterSlaveInterfaces {
  var slaveIdx = 0
  var masterIdx = 0
  def apply(that: Component)(f: (IMasterSlave, Int) => Boolean): Unit =
    traverse(that)(f)

  def traverse(that: Component)(f: (IMasterSlave, Int) => Boolean): Unit =
    that.getGroupedIO(true) map (process(_)(f))

  def traverse(b: Bundle)(f: (IMasterSlave, Int) => Boolean): Unit = 
    b.elements.map({ case (_, d) => process(d)(f) })

  def process(d: Data)(f: (IMasterSlave, Int) => Boolean): Unit = {
    d match {
      case ms: IMasterSlave =>
        val idx = if(ms.isMasterInterface) masterIdx else slaveIdx
        val done = f(ms, idx)

        if (done) {
          if(ms.isMasterInterface) masterIdx else slaveIdx = idx + 1
          return
        } 
      case _ =>
    }
    d match {
      case b: Bundle => traverse(b)(f)
      case _ =>
    }
  }
}

object XilinxNamer {
  def apply(comp: Component): Component = {
    var masterCnt = 0
    var slaveCnt = 0

    def doIt = {
      val ios = comp.getGroupedIO(true)

      name_clockDomain(comp.clockDomain)

      ios.foreach((io) => {
        io match {
          case ms: IMasterSlave => {
            val cnt = if (ms.isMasterInterface) masterCnt else slaveCnt
            if (ms.isMasterInterface) masterCnt = masterCnt + 1
            else slaveCnt = slaveCnt + 1

            io match {
              case axilite: AxiLite4 =>
                // TODO: AxiLite4XilinxRenamer(axilite, cnt)
              case _ =>
            }
          }
          case _ =>
        }
      })
    }

    comp.addPrePopTask(() => { doIt })
    comp
  }

  def name_clockDomain(cd: ClockDomain): Unit = {
    // val postfix = if(cd.name != "") "_" + cd.name else ""
    cd.clock.setName(
      "ACLK"
        + (cd.frequency match {
          // TODO: better formatting (e.g. 48M2)
          case f: FixedFrequency => f"_${f.getValue.toBigDecimal / 1000000}M"
          case _                 => ""
        })
    )

    if (cd.hasResetSignal) {
      cd.reset.setName(
        (if (cd.config.resetKind == ASYNC) "A" else "")
          + "RESET"
          + (if (cd.config.resetActiveLevel == HIGH) "" else "N")
      )
    }

    if (cd.hasClockEnableSignal) {
      cd.clockEnable.setName(
        "CE" + (if (cd.config.resetActiveLevel == HIGH) "" else "N")
      )
    }
  }
}
